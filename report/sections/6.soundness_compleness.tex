\section{\textit{Soundness} et \textit{Completeness} de l'analyse}

L'analyse statique que nous avons implémentée est \textit{complete} mais pas \textit{sound}.

\subsection{\textit{Soundness}}

Une analyse est considérée comme \textbf{sound} (correcte) si elle ne formule aucune affirmation erronée sur le programme. Dans notre cas, cela signifie que notre analyse fait preuve de \textbf{global soundness} : si elle signale un accès problématique à une variable, alors nous avons la garantie qu'il existe un scénario d'exécution concret où cet accès se produit réellement. Elle ne génère donc aucun faux positif. 

L’exemple suivant illustre un cas où ce n'est pas vérifié pour notre analyse :

\begin{lstlisting}[style=SmallLang]
main() {
    a = 0;
    t = spawn { b = 1; }
    c = a + 1;
    await t;
}
\end{lstlisting}

\begin{tikzpicture}[
    node distance=2cm,
    state/.style={rectangle, draw, rounded corners, minimum width=3.5cm, minimum height=1cm, align=center},
    thread/.style={dashed, draw, rounded corners, minimum width=4cm, minimum height=0.8cm, align=center}
]

    \node[state] (line1) {Line 2: a = 0 \\ \textbf{Write}};
    \node[state, below=of line1] (line2) {Line 3: t = spawn\{b = 1\} \\ \textbf{Write (spawn thread)}};
    \node[state, below=of line2] (line3) {Line 4: c = a + 1 \\ \textbf{Used (Read+Write)}};
    \node[state, below=of line3] (line4) {Line 5: await t \\ \textbf{Used}};

    \node[thread, right=4cm of line2] (spawn) {Spawn thread: b = 1 \\ \textbf{Write}};

    \draw[->, thick] (line1) -- (line2);
    \draw[->, thick] (line2) -- (line3);
    \draw[->, thick] (line3) -- (line4);

    \draw[->, thick, dashed] (line2.east) -- (spawn.west);
    \draw[->, thick, dashed] (spawn.west) -- (line4.east);

    \node[above=0.1cm of line2] {Thread parent};
    \node[above=0.1cm of spawn] {Thread child (spawn)};

\end{tikzpicture}

Dans cet exemple, notre analyse signale un accès problématique à la variable \texttt{a} dans le thread parent, car elle est lue après avoir été écrite. Cependant, comme le thread enfant n'accède pas à \texttt{a}, il n'y a pas de conflit réel. Ainsi, notre analyse génère un faux positif, ce qui prouve qu'elle n'est pas \textit{sound}.

\subsection{\textit{Completeness}}

Une analyse est considérée comme \textbf{complete} si elle signale systématiquement toutes les occurrences réelles de la propriété recherchée dans le programme. Dans notre cas, cela signifierait que notre analyse ne manque aucun accès problématique et ne produit aucun faux négatif. 

\begin{lstlisting}[style=SmallLang]
int a;
function increment() {
    a = a + 1;
}
main() {
    a = 3;
    t = spawn { increment(); }
    a = a + 1;
    await t;
}
\end{lstlisting}

\begin{tikzpicture}[
    node distance=2cm,
    state/.style={rectangle, draw, rounded corners, minimum width=3cm, minimum height=1cm, align=center},
    thread/.style={dashed, draw, rounded corners, minimum width=4cm, minimum height=0.8cm, align=center}
]

    \node[state] (line1) {Line 6: a = 3 \\ \textbf{Write}};
    \node[state, below=of line1] (line2) {Line 7: t = spawn\{increment()\} \\ \textbf{Write (spawn thread)}};
    \node[state, below=of line2] (line4) {Line 8: a = a + 1 \\ \textbf{Used (Read+Write)}};
    \node[state, below=of line4] (line5) {Line 9: await t \\ \textbf{Used}};

    \node[thread, right=4cm of line2] (spawn) {Spawn thread: increment() \\ Line 3: a = a + 1 \\ \textbf{Write}};

    \draw[->, thick] (line1) -- (line2);
    \draw[->, thick] (line2) -- (line4);
    \draw[->, thick] (line4) -- (line5);

    \draw[->, thick, dashed] (line2.east) -- (spawn.west);
    \draw[->, thick, dashed] (spawn.west) -- (line5.east);

    \node[above=0.1cm of line2] {Thread parent};
    \node[above=0.1cm of spawn] {Thread child (spawn)};

\end{tikzpicture}

Dans cet exemple, nous illustrons la \textit{completness} de notre analyse en montrant qu’aucun accès dangereux n'est ignoré.
Par ailleurs, notre analyse étant une analyse \textit{may}, celle-ci va donc dans le sens de la sur-approximation des comportements possibles du programme.
Notre analyse part donc du principe que nous nous trouvons dans le pire cas possible, ce qui la force à considérer tous les cas problématiques.
Ainsi, les choix de conception de notre analyse garantissent que toute situation dangereuse réelle est détectée, ce qui en fait une analyse \textit{complete} et \textit{safe} (mais pas \textit{sound}).

\subsection{\textit{Local Soundness}}


Une analyse est localement \textit{sound} si, pour chaque instruction individuelle, l'état concret possible après l’instruction est représenté dans l’approximation abstraite produite par l’analyse.
Pour prouver que notre analyse est localement \textit{sound}, nous prendrons une instruction d'assignation: \texttt{x = e}.
Cette instruction simple mais nécessaire, car elle génère à la fois un accès en écriture à la variable \texttt{x} et des accès en lecture aux variables utilisées dans l'expression \texttt{e}.

\subsubsection{Preuve}

Soit l'état concret \texttt{S}.

\paragraph{Cas 1 : Aucun accès concurrent avec écriture n’est possible}
L’exécution concrète de l’instruction produit uniquement des lectures et/ou écritures dans un même thread.

L’abstraction de l’état résultant est alors \texttt{Read}, \texttt{Write} ou \texttt{Read+Write}.
La \textit{flow function abstraite} produit exactement cette valeur ou une valeur plus générale.

\paragraph{Cas 2 : Un accès concurrent avec écriture est possible}
Une situation de concurrence existe dans l’exécution concrète.

L’abstraction de l’état concret est alors \texttt{Used}, et la \textit{flow function abstraite} produit également \texttt{Used}.

\subsubsection{Conclusion}

Dans tous les cas, on a :
\[
    \alpha(F_c(S)) \;\sqsubseteq\; F_a(\alpha(S))
\]

La \textit{flow function} associée à l’instruction \texttt{x = e} est donc \textit{local sound}, car elle sur-approxime toujours les effets de l’exécution concrète.